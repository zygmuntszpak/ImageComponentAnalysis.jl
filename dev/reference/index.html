<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function Reference · ImageComponentAnalysis.jl</title><link rel="canonical" href="https://zygmuntszpak.github.io/ImageComponentAnalysis.jl/stable/reference/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ImageComponentAnalysis.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Function Reference</a><ul class="internal"><li><a class="tocitem" href="#General-function-1"><span>General function</span></a></li><li><a class="tocitem" href="#Algorithms-1"><span>Algorithms</span></a></li><li><a class="tocitem" href="#Types-1"><span>Types</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/zygmuntszpak/ImageComponentAnalysis.jl/blob/master/docs/src/reference.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="function_reference-1"><a class="docs-heading-anchor" href="#function_reference-1">Function References</a><a class="docs-heading-anchor-permalink" href="#function_reference-1" title="Permalink"></a></h1><ul><li><a href="#function_reference-1">Function References</a></li><ul><li><a href="#General-function-1">General function</a></li><li><a href="#Algorithms-1">Algorithms</a></li><ul><li><a href="#BasicMeasurement-1">BasicMeasurement</a></li><li><a href="#BasicTopology-1">BasicTopology</a></li><li><a href="#BoundingBox-1">BoundingBox</a></li><li><a href="#MinimumOrientedBoundingBox-1">MinimumOrientedBoundingBox</a></li></ul><li><a href="#Types-1">Types</a></li><ul><li><a href="#DigitalContour-1">DigitalContour</a></li></ul></ul></ul><h2 id="General-function-1"><a class="docs-heading-anchor" href="#General-function-1">General function</a><a class="docs-heading-anchor-permalink" href="#General-function-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components" href="#ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components"><code>ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">analyze_components(components::AbstractArray{&lt;:Integer}, f::AbstractComponentAnalysisAlgorithm, args...; kwargs...)
analyze_components(components::AbstractArray{&lt;:Integer}, f::Tuple{AbstractComponentAnalysisAlgorithm, Vararg{AbstractComponentAnalysisAlgorithm}}, args...; kwargs...)</code></pre><p>Analyze connected components using algorithm <code>f</code> or sequence of algorithms specified in a tuple <code>fs</code>, and store the results in a <code>DataFrame</code>.</p><p><strong>Output</strong></p><p>The information about the components is stored in a <code>DataFrame</code>; each row number contains information corresponding to a particular connected component. The columns of the <code>DataFrame</code> will store the measurements that algorithm <code>f</code> or algorithms <code>fs</code> computes.</p><p><strong>Examples</strong></p><p>Pass an array of labelled connected components and component analysis algorithm to <code>analyze_component</code>.</p><pre><code class="language-julia">f = BasicMeasurement()
analyze_components = analyze_component(components, f)

fs = tuple(RegionEllipse(), Contour())
analyze_components!(df, components, fs)</code></pre><p>The first example reads as &quot;<code>analyze_components</code> of connected <code>components</code> using algorithm <code>f</code>&quot;.</p><p>See also <a href="#ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components!"><code>analyze_components!</code></a> for appending information about connected components to an existing <code>DataFrame</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zygmuntszpak/ImageComponentAnalysis.jl/blob/e718c8b17d99a9fc033ae20492a150260b1ce75b/src/ComponentAnalysisAPI/component_analysis.jl#L140-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components!" href="#ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components!"><code>ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">analyze_components!(dataframe::AbstractDataFrame, components::AbstractArray{&lt;:Integer}, f::AbstractComponentAnalysisAlgorithm, args...; kwargs...)
analyze_components!(dataframe::AbstractDataFrame, components::AbstractArray{&lt;:Integer}, fs::Tuple{AbstractComponentAnalysisAlgorithm, Vararg{AbstractComponentAnalysisAlgorithm}}, args...; kwargs...)</code></pre><p>Analyze connected components using component analysis algorithm <code>f</code> or sequence of algorithms specified in a tuple <code>fs</code>,  and store the results in a <code>DataFrame</code>.</p><p><strong>Output</strong></p><p>The information about the components is stored in a <code>DataFrame</code>; each row number contains information corresponding to a particular connected component. The <code>DataFrame</code> will be changed in place and its columns will store the measurements that algorithm <code>f</code> or algorithms <code>fs</code> computes.</p><p><strong>Examples</strong></p><p>Just simply pass an algorithm to <code>analyze_components!</code>:</p><pre><code class="language-julia">df = DataFrame()
f = BasicMeasurement()
analyze_components!(df, components, f)

fs = tuple(RegionEllipse(), Contour())
analyze_components!(df, components, fs)</code></pre><p>See also: <a href="#ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components"><code>analyze_components</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zygmuntszpak/ImageComponentAnalysis.jl/blob/e718c8b17d99a9fc033ae20492a150260b1ce75b/src/ComponentAnalysisAPI/component_analysis.jl#L109-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageComponentAnalysis.establish_contour_hierarchy" href="#ImageComponentAnalysis.establish_contour_hierarchy"><code>ImageComponentAnalysis.establish_contour_hierarchy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    establish_contour_hierarchy(labels::AbstractArray{&lt;:Integer})</code></pre><p>Traces the contour of both the outer boundary and hole boundary of each labelled component and stores the hierarichal relationship among the contours in a tree data structure.</p><p><strong>Details</strong></p><p>The tree is of type <a href="https://github.com/JuliaCollections/LeftChildRightSiblingTrees.jl"><code>LeftChildRightSiblingTree</code></a> and you can use the functionality from the <a href="https://github.com/JuliaCollections/AbstractTrees.jl"><code>AbstractTrees.jl</code></a> package to iterate over it.</p><p>Each <code>Node</code> of the tree has a <code>data</code> field of type <a href="@ref"><code>DigitalContour</code></a>.</p><p>The parent/child relationship of the tree reflects the nesting of connected components. If a connected component is wholly contained within another connected component, then its contours will be children of the contours of its surrounding connected component.</p><p><strong>Example</strong></p><pre><code class="language-julia">using ImageComponentAnalysis, TestImages, ImageBinarization, ImageCore, AbstractTrees, Parameters

img = Gray.(testimage(&quot;blobs&quot;))
img2 = binarize(img, Otsu())
components = label_components(img2, trues(3,3), 1)
tree = establish_contour_hierarchy(components)

# Iterate over all DigitalContour&#39;s in the tree.
for node in PostOrderDFS(tree)
    @unpack id, is_outer, pixels node.data # See Parameters.jl for &quot;@unpack&quot;
    @show id, is_outer, pixels
end</code></pre><p><strong>Reference</strong></p><ol><li>S. Suzuki and K. Abe, “Topological structural analysis of digitized binary images by border following,” Computer Vision, Graphics, and Image Processing, vol. 29, no. 3, p. 396, Mar. 1985.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zygmuntszpak/ImageComponentAnalysis.jl/blob/e718c8b17d99a9fc033ae20492a150260b1ce75b/src/algorithms/contour_topology.jl#L66-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageComponentAnalysis.label_components" href="#ImageComponentAnalysis.label_components"><code>ImageComponentAnalysis.label_components</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">label_components(tf, [connectivity])
label_components(tf, [region])</code></pre><p>Find the connected components in a binary array <code>tf</code>. There are two forms that <code>connectivity</code> can take.</p><p>(1) It can be a boolean array of the same dimensionality as <code>tf</code>, of size 1 or 3 along each dimension. Each entry in the array determines whether a given neighbor is used for connectivity analyses. For example, <code>connectivity = trues(3,3)</code> would use 8-connectivity and test all pixels that touch the current one, even the corners.</p><p>(2) You can provide a list indicating which dimensions are used to determine connectivity. For example, <code>region = [1,3]</code> would not test neighbors along dimension 2 for connectivity. This corresponds to just the nearest neighbors, i.e., 4-connectivity in 2d and 6-connectivity in 3d. The default is <code>region = 1:ndims(A)</code>. The output <code>label</code> is an integer array, where 0 is used for background pixels, and each connected region gets a different integer index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zygmuntszpak/ImageComponentAnalysis.jl/blob/e718c8b17d99a9fc033ae20492a150260b1ce75b/src/label_components.jl#L7-L28">source</a></section></article><h2 id="Algorithms-1"><a class="docs-heading-anchor" href="#Algorithms-1">Algorithms</a><a class="docs-heading-anchor-permalink" href="#Algorithms-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ImageComponentAnalysis.ComponentAnalysisAPI.AbstractComponentAnalysisAlgorithm" href="#ImageComponentAnalysis.ComponentAnalysisAPI.AbstractComponentAnalysisAlgorithm"><code>ImageComponentAnalysis.ComponentAnalysisAPI.AbstractComponentAnalysisAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractComponentAnalysisAlgorithm &lt;: AbstractComponentAnalysis</code></pre><p>The root type for <code>ImageComponentAnalysis</code> package.</p><p>Any concrete component analysis algorithm shall subtype it to support <a href="#ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components"><code>analyze_components</code></a> and <a href="#ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components!"><code>analyze_components!</code></a> APIs.</p><p><strong>Examples</strong></p><p>All component analysis algorithms in <code>ImageComponentAnalysis</code> are called in the following pattern:</p><pre><code class="language-julia"># determine the connected components and label them
components = label_components(binary_image)

# generate an algorithm instance
f = BasicMeasurement(area = true, perimiter = true)

# then pass the algorithm to `analyze_components`
measurements = analyze_components(components, f)

# or use in-place version `analyze_components!`
g = BoundingBox(area = true)
analyze_components!(measurements, components, g)</code></pre><p>You can run a sequence of analyses by passing a tuple of the relevant algorithms. For example,</p><pre><code class="language-julia"># determine the connected components and label them
components = label_components(binary_image)

# generate algorithm instances
p = Contour()
q = MinimumOrientedBoundingBox(oriented_box_aspect_ratio = false)
r = EllipseRegion(semiaxes = true)

# then pass the algorithm to `analyze_components`
measurements = analyze_components(components, tuple(p, q, r))

# or use in-place version `analyze_components!`
analyze_components!(measurements, components, tuple(p, q, r))</code></pre><p>Most algorithms receive additional information as an argument, such as <code>area</code> or <code>perimeter</code> of <code>BasicMeasurement</code>. In general, arguments are boolean flags that signal whether or not to include a particular feature in the analysis.</p><pre><code class="language-julia"># you can explicit specify whether or not you wish to report certain
# properties
f = BasicMeasurement(area = false, perimiter = true)</code></pre><p>For more examples, please check <a href="#ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components"><code>analyze_components</code></a>, <a href="#ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components!"><code>analyze_components!</code></a> and concrete algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zygmuntszpak/ImageComponentAnalysis.jl/blob/e718c8b17d99a9fc033ae20492a150260b1ce75b/src/ComponentAnalysisAPI/component_analysis.jl#L6-L66">source</a></section></article><h3 id="BasicMeasurement-1"><a class="docs-heading-anchor" href="#BasicMeasurement-1">BasicMeasurement</a><a class="docs-heading-anchor-permalink" href="#BasicMeasurement-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ImageComponentAnalysis.BasicMeasurement" href="#ImageComponentAnalysis.BasicMeasurement"><code>ImageComponentAnalysis.BasicMeasurement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">    BasicMeasurement &lt;: AbstractComponentAnalysisAlgorithm
    BasicMeasurement(; area = true,  perimeter = true)
    analyze_components(components, f::BasicMeasurement)
    analyze_components!(dataframe::AbstractDataFrame, components, f::BasicMeasurement)</code></pre><p>Takes as input an array of labelled connected components and returns a <code>DataFrame</code> with columns that store basic measurements, such as <code>area</code> and <code>perimeter</code>, of each component.</p><p><strong>Details</strong></p><p>The <code>area</code> and <code>perimeter</code> measures are derived from <em>bit-quad</em> patterns, which are certain 2 × 2 pixel patterns described in [1]. Hence, the function adds six bit-quad patterns to the <code>DataFrame</code> under column names <code>Q₀, Q₁, Q₂, Q₃, Q₄</code> and <code>Qₓ</code>.</p><p>The function returns two measures for the <code>perimeter</code>, <em>perimiter₀</em> and <em>perimter₁</em>, which are given by equations 18.2-8b and 18.2-7a in [2]</p><p><strong>Example</strong></p><pre><code class="language-julia">using ImageComponentAnalysis, TestImages, ImageBinarization, ColorTypes

img = Gray.(testimage(&quot;blobs&quot;))
img2 = binarize(img, Otsu())
components = label_components(img2, trues(3,3), 1)
measurements = analyze_components(components, BasicMeasurement(area = true, perimeter = false))
</code></pre><p><strong>References</strong></p><ol><li>S. B. Gray, “Local Properties of Binary Images in Two Dimensions,” IEEE Transactions on Computers, vol. C–20, no. 5, pp. 551–561, May 1971.</li><li>Pratt, William K., Digital Image Processing, New York, John Wiley &amp; Sons, Inc., 1991, p. 629.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zygmuntszpak/ImageComponentAnalysis.jl/blob/e718c8b17d99a9fc033ae20492a150260b1ce75b/src/algorithms/basic_measurement.jl#L1-L39">source</a></section></article><h3 id="BasicTopology-1"><a class="docs-heading-anchor" href="#BasicTopology-1">BasicTopology</a><a class="docs-heading-anchor-permalink" href="#BasicTopology-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ImageComponentAnalysis.BasicTopology" href="#ImageComponentAnalysis.BasicTopology"><code>ImageComponentAnalysis.BasicTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">    BasicTopology &lt;: AbstractComponentAnalysisAlgorithm
    BasicTopology(; holes = true,  euler_number = true)
    analyze_components(components, f::BasicTopolgy)
    analyze_components!(dataframe::AbstractDataFrame, components, f::BasicTopolgy)</code></pre><p>Takes as input an array of labelled connected components and returns a <code>DataFrame</code> with columns that store basic topological properties for each component, such as the <code>euler_number</code> and the total number of <code>holes</code>.</p><p>The function returns two variants of the <code>euler_number</code>: <code>euler₄</code> and <code>euler₈</code> which correspond to a <code>4-connected</code> versus <code>8-connected</code> neighbourhood.</p><p>The <code>euler_number</code> and number of <code>holes</code> are derived from <em>bit-quad</em> patterns, which are certain 2 × 2 pixel patterns described in [1]. Hence, the function adds six bit-quad patterns to the <code>DataFrame</code> under column names <code>Q₀, Q₁, Q₂, Q₃, Q₄</code> and <code>Qₓ</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">using ImageComponentAnalysis, TestImages, ImageBinarization, ColorTypes

img = Gray.(testimage(&quot;blobs&quot;))
img2 = binarize(img, Otsu())
components = label_components(img2, trues(3,3), 1)
measurements = analyze_components(components, BasicTopology(holes = true, euler_number = true))
</code></pre><p><strong>Reference</strong></p><ol><li>S. B. Gray, “Local Properties of Binary Images in Two Dimensions,” IEEE Transactions on Computers, vol. C–20, no. 5, pp. 551–561, May 1971.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zygmuntszpak/ImageComponentAnalysis.jl/blob/e718c8b17d99a9fc033ae20492a150260b1ce75b/src/algorithms/basic_topology.jl#L1-L36">source</a></section></article><h3 id="BoundingBox-1"><a class="docs-heading-anchor" href="#BoundingBox-1">BoundingBox</a><a class="docs-heading-anchor-permalink" href="#BoundingBox-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ImageComponentAnalysis.BoundingBox" href="#ImageComponentAnalysis.BoundingBox"><code>ImageComponentAnalysis.BoundingBox</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">    BoundingBox &lt;: AbstractComponentAnalysisAlgorithm
    BoundingBox(;  box_area = true)
    analyze_components(components, f::BoundingBox)
    analyze_components!(df::AbstractDataFrame, components, f::BoundingBox)</code></pre><p>Takes as input an array of labelled connected components and returns a <code>DataFrame</code> with columns that store a tuple of <code>StepRange</code> types that demarcate the minimum (image axis-aligned) bounding box of each component.</p><p>The function can optionally also return the box area.</p><p><strong>Example</strong></p><pre><code class="language-julia">using ImageComponentAnalysis, TestImages, ImageBinarization, ColorTypes

img = Gray.(testimage(&quot;blobs&quot;))
img2 = binarize(img, Otsu())
components = label_components(img2, trues(3,3), 1)
measurements = analyze_components(components, BoundingBox(box_area = true))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zygmuntszpak/ImageComponentAnalysis.jl/blob/e718c8b17d99a9fc033ae20492a150260b1ce75b/src/algorithms/bounding_box.jl#L1-L26">source</a></section></article><h3 id="MinimumOrientedBoundingBox-1"><a class="docs-heading-anchor" href="#MinimumOrientedBoundingBox-1">MinimumOrientedBoundingBox</a><a class="docs-heading-anchor-permalink" href="#MinimumOrientedBoundingBox-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ImageComponentAnalysis.MinimumOrientedBoundingBox" href="#ImageComponentAnalysis.MinimumOrientedBoundingBox"><code>ImageComponentAnalysis.MinimumOrientedBoundingBox</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">    MinimumOrientedBoundingBox &lt;: AbstractComponentAnalysisAlgorithm
    MinimumOrientedBoundingBox(;  oriented_box_area = true, oriented_box_aspect_ratio = true)
    analyze_components(components, f::MinimumOrientedBoundingBox)
    analyze_components!(df::AbstractDataFrame, components, f::MinimumOrientedBoundingBox)</code></pre><p>Takes as input an array of labelled connected components and returns a <code>DataFrame</code> with columns that store a length-4 vector containing the four corner points of the minimum oriented bounding box of each component. It optionally also returns the area and aspect ratio of the minimum oriented bounding box.</p><p><strong>Example</strong></p><pre><code class="language-julia">using ImageComponentAnalysis, TestImages, ImageBinarization, ColorTypes

img = Gray.(testimage(&quot;blobs&quot;))
img2 = binarize(img, Otsu())
components = label_components(img2, trues(3,3), 1)
algorithm = MinimumOrientedBoundingBox(oriented_box_area = true, oriented_box_aspect_ratio = true)
measurements = analyze_components(components, algorithm)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zygmuntszpak/ImageComponentAnalysis.jl/blob/e718c8b17d99a9fc033ae20492a150260b1ce75b/src/algorithms/minimum_oriented_bounding_box.jl#L1-L26">source</a></section></article><h2 id="Types-1"><a class="docs-heading-anchor" href="#Types-1">Types</a><a class="docs-heading-anchor-permalink" href="#Types-1" title="Permalink"></a></h2><h3 id="DigitalContour-1"><a class="docs-heading-anchor" href="#DigitalContour-1">DigitalContour</a><a class="docs-heading-anchor-permalink" href="#DigitalContour-1" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DigitalContour</code>. Check Documenter&#39;s build log for details.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 16 October 2021 00:13">Saturday 16 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
