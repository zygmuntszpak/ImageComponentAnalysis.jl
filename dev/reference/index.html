<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function Reference · Documentation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Documentation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Function Reference</a><ul class="internal"><li><a class="toctext" href="#General-function-1">General function</a></li><li><a class="toctext" href="#Algorithms-1">Algorithms</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Function Reference</a></li></ul><a class="edit-page" href="https://github.com/zygmuntszpak/ImageComponentAnalysis.jl/blob/master/docs/src/reference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Function Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="function_reference-1" href="#function_reference-1">Function References</a></h1><ul><li><a href="#function_reference-1">Function References</a></li><ul><li><a href="#General-function-1">General function</a></li><li><a href="#Algorithms-1">Algorithms</a></li><ul><li><a href="#BasicMeasurement-1">BasicMeasurement</a></li><li><a href="#BasicTopology-1">BasicTopology</a></li><li><a href="#BoundingBox-1">BoundingBox</a></li><li><a href="#MinimumOrientedBoundingBox-1">MinimumOrientedBoundingBox</a></li></ul></ul></ul><h2><a class="nav-anchor" id="General-function-1" href="#General-function-1">General function</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components" href="#ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components"><code>ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">analyze_components(components::AbstractArray{&lt;:Integer}, f::AbstractComponentAnalysisAlgorithm, args...; kwargs...)</code></pre><p>Analyze connected components using algorithm <code>f</code>.</p><p><strong>Output</strong></p><p>The information about the components is stored in a <code>DataFrame</code>; each row number contains information corresponding to a particular connected component.</p><p><strong>Examples</strong></p><p>Pass an array of labelled connected components and component analysis algorithm to <code>analyze_component</code>.</p><pre><code class="language-julia">f = BasicMeasurement()
analyze_components = analyze_component(components, f)</code></pre><p>This reads as &quot;<code>analyze_components</code> of connected <code>components</code> using algorithm <code>f</code>&quot;.</p><p>See also <a href="#ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components!"><code>analyze_components!</code></a> for appending information about connected components to an existing <code>DataFrame</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageComponentAnalysis.jl/blob/6109bac44f0ba381392345cdde9e9099220c075e/src/ComponentAnalysisAPI/component_analysis.jl#L102-L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components!" href="#ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components!"><code>ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">analyze_components!(dataframe::AbstractDataFrame, components::AbstractArray{&lt;:Integer}, f::AbstractComponentAnalysisAlgorithm, args...; kwargs...)</code></pre><p>Analyze connected components using component analysis algorithm <code>f</code> and store the results in a <code>DataFrame</code>.</p><p><strong>Output</strong></p><p>The <code>DataFrame</code> will be changed in place and its columns will store the measurements that algorithm <code>f</code> computes.</p><p><strong>Examples</strong></p><p>Just simply pass an algorithm to <code>analyze_components!</code>:</p><pre><code class="language-julia">df = DataFrame()
f = BasicMeasurement()
analyze_components!(df, components, f)</code></pre><p>See also: <a href="#ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components"><code>analyze_components</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageComponentAnalysis.jl/blob/6109bac44f0ba381392345cdde9e9099220c075e/src/ComponentAnalysisAPI/component_analysis.jl#L77-L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageComponentAnalysis.label_components" href="#ImageComponentAnalysis.label_components"><code>ImageComponentAnalysis.label_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">label_components(tf, [connectivity])
label_components(tf, [region])</code></pre><p>Find the connected components in a binary array <code>tf</code>. There are two forms that <code>connectivity</code> can take.</p><p>(1) It can be a boolean array of the same dimensionality as <code>tf</code>, of size 1 or 3 along each dimension. Each entry in the array determines whether a given neighbor is used for connectivity analyses. For example, <code>connectivity = trues(3,3)</code> would use 8-connectivity and test all pixels that touch the current one, even the corners.</p><p>(2) You can provide a list indicating which dimensions are used to determine connectivity. For example, <code>region = [1,3]</code> would not test neighbors along dimension 2 for connectivity. This corresponds to just the nearest neighbors, i.e., 4-connectivity in 2d and 6-connectivity in 3d. The default is <code>region = 1:ndims(A)</code>. The output <code>label</code> is an integer array, where 0 is used for background pixels, and each connected region gets a different integer index.</p></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageComponentAnalysis.jl/blob/6109bac44f0ba381392345cdde9e9099220c075e/src/label_components.jl#L7-L28">source</a></section><h2><a class="nav-anchor" id="Algorithms-1" href="#Algorithms-1">Algorithms</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageComponentAnalysis.ComponentAnalysisAPI.AbstractComponentAnalysisAlgorithm" href="#ImageComponentAnalysis.ComponentAnalysisAPI.AbstractComponentAnalysisAlgorithm"><code>ImageComponentAnalysis.ComponentAnalysisAPI.AbstractComponentAnalysisAlgorithm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractComponentAnalysisAlgorithm &lt;: AbstractComponentAnalysis</code></pre><p>The root type for <code>ImageComponentAnalysis</code> package.</p><p>Any concrete component analysis algorithm shall subtype it to support <a href="#ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components"><code>analyze_components</code></a> and <a href="#ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components!"><code>analyze_components!</code></a> APIs.</p><p><strong>Examples</strong></p><p>All component analysis algorithms in <code>ImageComponentAnalysis</code> are called in the following pattern:</p><pre><code class="language-julia"># determine the connected components and label them
components = label_components(binary_image)

# generate an algorithm instance
f = BasicMeasurement(area = true, perimiter = true)

# then pass the algorithm to `analyze_components`
measurements = analyze_components(components, f)

# or use in-place version `analyze_components!`
g = BoundingBox(area = true)
analyze_components!(measurements, components, g)</code></pre><p>Most algorithms receive additional information as an argument such as <code>area</code> or <code>perimeter</code> of <code>BasicMeasurement</code>.</p><pre><code class="language-julia"># you can explicit specify whether or not you wish to report certain
# properties
f = BasicMeasurement(area = false, perimiter = true)</code></pre><p>For more examples, please check <a href="#ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components"><code>analyze_components</code></a>, <a href="#ImageComponentAnalysis.ComponentAnalysisAPI.analyze_components!"><code>analyze_components!</code></a> and concrete algorithms.</p></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageComponentAnalysis.jl/blob/6109bac44f0ba381392345cdde9e9099220c075e/src/ComponentAnalysisAPI/component_analysis.jl#L6-L45">source</a></section><h3><a class="nav-anchor" id="BasicMeasurement-1" href="#BasicMeasurement-1">BasicMeasurement</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageComponentAnalysis.BasicMeasurement" href="#ImageComponentAnalysis.BasicMeasurement"><code>ImageComponentAnalysis.BasicMeasurement</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">    BasicMeasurement &lt;: AbstractComponentAnalysisAlgorithm
    BasicMeasurement(; area = true,  perimeter = true)
    analyze_components(components, f::BasicMeasuremen)
    analyze_components!(dataframe::AbstractDataFrame, components, f::BasicMeasurement)</code></pre><p>Takes as input an array of labelled connected components and returns a <code>DataFrame</code> with columns that store basic measurements, such as <code>area</code> and <code>perimeter</code>, of each component.</p><p><strong>Details</strong></p><p>The <code>area</code> and <code>perimeter</code> measures are derived from <em>bit-quad</em> patterns, which are certain 2 × 2 pixel patterns described in [1]. Hence, the function adds six bit-quad patterns to the <code>DataFrame</code> under column names <code>Q₀, Q₁, Q₂, Q₃, Q₄</code> and <code>Qₓ</code>.</p><p>The function returns two measures for the <code>perimeter</code>, <em>perimiter₀</em> and <em>perimter₁</em>, which are given by equations 18.2-8b and 18.2-7a in [2]</p><p><strong>Example</strong></p><pre><code class="language-julia">using ImageComponentAnalysis, TestImages, ImageBinarization, ColorTypes

img = Gray.(testimage(&quot;blobs&quot;))
img2 = binarize(img, Otsu())
components = label_components(img2, trues(3,3), 1)
measurements = analyze_components(components, BasicMeasurement(area = true, perimeter = false))
</code></pre><p><strong>References</strong></p><ol><li>S. B. Gray, “Local Properties of Binary Images in Two Dimensions,” IEEE Transactions on Computers, vol. C–20, no. 5, pp. 551–561, May 1971.</li><li>Pratt, William K., Digital Image Processing, New York, John Wiley &amp; Sons, Inc., 1991, p. 629.</li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/55e36cc308b66d3472990a06b2797f9f9154ea0a/base/#L0-L38">source</a></section><h3><a class="nav-anchor" id="BasicTopology-1" href="#BasicTopology-1">BasicTopology</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageComponentAnalysis.BasicTopology" href="#ImageComponentAnalysis.BasicTopology"><code>ImageComponentAnalysis.BasicTopology</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">    BasicTopology &lt;: AbstractComponentAnalysisAlgorithm
    BasicTopology(; holes = true,  euler_number = true)
    analyze_components(components, f::BasicTopolgy)
    analyze_components!(dataframe::AbstractDataFrame, components, f::BasicTopolgy)</code></pre><p>Takes as input an array of labelled connected components and returns a <code>DataFrame</code> with columns that store basic topological properties for each component, such as the <code>euler_number</code> and the total number of <code>holes</code>.</p><p>The function returns two variants of the <code>euler_number</code>: <code>euler₄</code> and <code>euler₈</code> which correspond to a <code>4-connected</code> versus <code>8-connected</code> neighbourhood.</p><p>The <code>euler_number</code> and number of <code>holes</code> are derived from <em>bit-quad</em> patterns, which are certain 2 × 2 pixel patterns described in [1]. Hence, the function adds six bit-quad patterns to the <code>DataFrame</code> under column names <code>Q₀, Q₁, Q₂, Q₃, Q₄</code> and <code>Qₓ</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">using ImageComponentAnalysis, TestImages, ImageBinarization, ColorTypes

img = Gray.(testimage(&quot;blobs&quot;))
img2 = binarize(img, Otsu())
components = label_components(img2, trues(3,3), 1)
measurements = analyze_components(components, BasicTopology(holes = true, euler_number = true))
</code></pre><p><strong>Reference</strong></p><ol><li>S. B. Gray, “Local Properties of Binary Images in Two Dimensions,” IEEE Transactions on Computers, vol. C–20, no. 5, pp. 551–561, May 1971.</li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/55e36cc308b66d3472990a06b2797f9f9154ea0a/base/#L0-L35">source</a></section><h3><a class="nav-anchor" id="BoundingBox-1" href="#BoundingBox-1">BoundingBox</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageComponentAnalysis.BoundingBox" href="#ImageComponentAnalysis.BoundingBox"><code>ImageComponentAnalysis.BoundingBox</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">    BoundingBox &lt;: AbstractComponentAnalysisAlgorithm
    BoundingBox(;  box_area = true)
    analyze_components(components, f::BoundingBox)
    analyze_components!(df::AbstractDataFrame, components, f::BoundingBox)</code></pre><p>Takes as input an array of labelled connected components and returns a <code>DataFrame</code> with columns that store a tuple of <code>StepRange</code> types that demarcate the minimum (image axis-aligned) bounding box of each component.</p><p>The function can optionally also return the box area.</p><p><strong>Example</strong></p><pre><code class="language-julia">using ImageComponentAnalysis, TestImages, ImageBinarization, ColorTypes

img = Gray.(testimage(&quot;blobs&quot;))
img2 = binarize(img, Otsu())
components = label_components(img2, trues(3,3), 1)
measurements = analyze_components(components, BoundingBox(box_area = true))
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/55e36cc308b66d3472990a06b2797f9f9154ea0a/base/#L0-L25">source</a></section><h3><a class="nav-anchor" id="MinimumOrientedBoundingBox-1" href="#MinimumOrientedBoundingBox-1">MinimumOrientedBoundingBox</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageComponentAnalysis.MinimumOrientedBoundingBox" href="#ImageComponentAnalysis.MinimumOrientedBoundingBox"><code>ImageComponentAnalysis.MinimumOrientedBoundingBox</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">    MinimumOrientedBoundingBox &lt;: AbstractComponentAnalysisAlgorithm
    MinimumOrientedBoundingBox(;  oriented_box_area = true, oriented_box_aspect_ratio = true)
    analyze_components(components, f::MinimumOrientedBoundingBox)
    analyze_components!(df::AbstractDataFrame, components, f::MinimumOrientedBoundingBox)</code></pre><p>Takes as input an array of labelled connected components and returns a <code>DataFrame</code> with columns that store a length-4 vector containing the four corner points of the minimum oriented bounding box of each component. It optionally also returns the area and aspect ration of the minimum oriented bounding box.</p><p><strong>Example</strong></p><pre><code class="language-julia">using ImageComponentAnalysis, TestImages, ImageBinarization, ColorTypes

img = Gray.(testimage(&quot;blobs&quot;))
img2 = binarize(img, Otsu())
components = label_components(img2, trues(3,3), 1)
measurements = analyze_components(components, MinimumOrientedBoundingBox(oriented_box_area = true, oriented_box_aspect_ratio = true))
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/55e36cc308b66d3472990a06b2797f9f9154ea0a/base/#L0-L24">source</a></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a></footer></article></body></html>
